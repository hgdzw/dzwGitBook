### 1. 为啥会有锁 ？
   单线程的情况下 是不会有锁的情况的,也就是 都是自己执行的 不用考虑多个线程 并发 加锁的情况
   所以 多线程情况下需要考虑锁的问题,也就是当多个线程可能同时访问一个资源的时候,就要考虑这个资源在一个时刻在每个线程中是不是一样的    
   也就是解决了多线程中的**可见性**问题.
   
### 2. 线程安全
   当出现并发的时候就要考虑线程安全的问题了,线程安全的定义也是不同的 对于颗粒度的定义,比如线程安全可以分为以下几种
   * 不可变: 也就是属性永远不会改变 其他的线程也就看不到值不一样的了
   * 绝对线程安全: 所有的属性和方法都加上synchronized修饰
   * 相对线程安全: 对于一些特定顺序的连续调用,可以加上synchronized
   * 线程兼容: 对象本身不是线程安全的,但是调用者正确使用同步手段来保证线程安全
   * 线程对立: 值得是无论调用者怎么使用同步手段 都无法保证线程安全 这个是不被使用的一种
   
   一般我们都是相对线程安全,对可能会发生线程不安全的代码进行解决,解决方案一般是以下几种。
   * 互斥同步: 最常见的一种方式,就是并发访问共享数据时,对共享数据**加锁**,让这个数据同一时间只能被一个线程访问,互斥是手段 同步是目的,悲观锁
   * 非互斥同步: 互斥同步的时候其实是悲观锁,我们可以通过cas(Compare-and-swap)比较并替换的形式加一个乐观锁
   * 无同步方案: 当没有涉及到共享数据的时候其实并发就不会存在不安全 这个时候是不用进行线程安全考虑的.


### 3.锁的实现？

### 3.1  synchronized   其使用监视器 (monitor) 来实现
   加在方法的前面 表示调用到这个方法的时候 同一时间只有一个实例可以调用 其他的调用的时候会等待
    是一个自动挡  会自动 --> 偏向锁   --> 轻量级锁（自旋锁）  ——>重量级锁    这都是自己实现的
    
### 3.2  Lock
  JDK 1.5 之后才引用的 一个接口  位于JUC 包下  
  使用: 有几个重要的实现  ReentrantLock  ReadWriteLock  
    java自带的锁 我不知道怎么实现的  但是这个老师傅Lock 的锁是咋实现的 这个就有点好奇了
        这里主要有 AQS 实现 AQS 好像是一个 实现锁的 一个同步框架啥的
   这里比如  ReentrantLock（可重入 在解锁之前重复获取锁 每次解锁操作会反转一次加锁产生的效果。） 这个锁 实现了 Lock
        但是内部 是用 Sync extends AbstractQueued synchronize 来管理锁的
```
公平锁 集成 Sync
    数据结构:  是一个链表结构
        waitStatus :  -1 说明当前线程正在执行 其他线程判断到当前这个线程在 -1 时 会休眠等待这个唤醒
        prev Node  ： 前驱节点
        next Node  ： 后续节点
        thread    ： 当前线程
    尝试加锁lock()
        如果状态是0 将当前线程设置为共享的线程 状态+ 1
        如果不为0  判断是不是当前线程 如果是 再 + 1
        如果都不是
            队列不为空   加到队列最后面  pre = node    node.next = 当前
            否则  enq()  自旋锁方式入队
        判断需不需要挂起
            如果前驱等于 -1 说明前驱节点正常 直接挂起  等待前驱节点结束 唤醒你
    尝试释放锁 unlock()
         判断一下是不是我这个线程当前锁
         如果是   判断是不是可重入 不重入直接释放  重入 state -1
         唤醒后继节点
非公平锁  继承Sync
    尝试加锁  lock()
        首先 cas 获取锁一次  如果没有的话  判断 如果state == 0 的时候 直接强锁
            这个会导致 如果是公平锁和非公平锁同时进入 非公平锁会得到锁 这是不公平的

```

### 4.如何避免死锁(不要盲目加锁)
   * 互斥: 一个资源同一时间只能被一个进程使用
   * 不可剥夺条件： 在进程使用资源的时候不能对这个资源进行强行剥夺
   * 请求与保持条件： 当这个进程进行阻塞的时候 会对以持有的资源不放
   * 循环等待条件： 若干进程之间形成收尾相接的循环等待条件。
   要防止死锁的话就破坏上面四个条件就行了 第一个互斥是不能被破坏的,因为我们加锁就是让他互斥的 所以 就破坏其他三个就行了





