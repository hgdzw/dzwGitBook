## 1. 为啥会有锁 ？

   单线程的情况下 是不会有锁的情况的  也就是 都是自己执行的 不用考虑多个线程 并发 加锁的情况
    所以 多线程情况下需要考虑锁的问题


## 2.产生死锁的条件
   * 互斥: 一个资源同一时间只能被一个进程使用
   * 不可剥夺条件： 在进程使用资源的时候不能对这个资源进行强行剥夺
   * 请求与保持条件： 当这个进程进行阻塞的时候 会对以持有的资源不放
   * 循环等待条件： 若干进程之间形成收尾相接的循环等待条件。
   要防止死锁的话就破坏上面四个条件就行了 第一个互斥是不能被破坏的 所以 就破坏其他三个就行了

## 3. 线程安全的实现
   1.互斥同步
   
##2.  锁的实现？
###2.1  synchronized   其使用监视器 (monitor) 来实现
加在方法的前面 表示调用到这个方法的时候 同一时间只有一个实例可以调用 其他的调用的时候会等待
        是一个自动挡  会自动 --> 偏向锁   --> 轻量级锁（自旋锁）  ——>重量级锁    这都是自己实现的
###2.2  Lock
  JDK 1.5 之后才引用的 一个接口  位于JUC 包下
  使用: 有几个重要的实现  ReentrantLock  ReadWriteLock
    java自带的锁 我不知道怎么实现的  但是这个老师傅Lock 的锁是咋实现的 这个就有点好奇了
        这里主要有 AQS 实现 AQS 好像是一个 实现锁的 一个同步框架啥的
   这里比如  ReentrantLock（可重入 在解锁之前重复获取锁 每次解锁操作会反转一次加锁产生的效果。） 这个锁 实现了 Lock
        但是内部 是用 Sync extends AbstractQueuedSynchronizer 来管理锁的
        --   公平锁 集成 Sync
                数据结构:  是一个链表结构
                    waitStatus :  -1 说明当前线程正在执行 其他线程判断到当前这个线程在 -1 时 会休眠等待这个唤醒
                    prev Node  ： 前驱节点
                    next Node  ： 后续节点
                    thread    ： 当前线程
                尝试加锁lock()
                    如果状态是0 将当前线程设置为共享的线程 状态+ 1
                    如果不为0  判断是不是当前线程 如果是 再 + 1
                    如果都不是
                        队列不为空   加到队列最后面  pre = node    node.next = 当前
                        否则  enq()  自旋锁方式入队
                    判断需不需要挂起
                        如果前驱等于 -1 说明前驱节点正常 直接挂起  等待前驱节点结束 唤醒你
                尝试释放锁 unlock()
                     判断一下是不是我这个线程当前锁
                     如果是   判断是不是可重入 不重入直接释放  重入 state -1
                     唤醒后继节点
            非公平锁  继承Sync
                尝试加锁  lock()
                    首先 cas 获取锁一次  如果没有的话  判断 如果state == 0 的时候 直接强锁
                        这个会导致 如果是公平锁和非公平锁同时进入 非公平锁会得到锁 这是不公平的






