
###1. 什么是gc gc 有什么用
   套用一句话 围墙里的人想出去 围墙外的人想进来 java的内存管理机制就是一道围墙 程序员不需要知道内存中的事 不要直接和内存打交道
    gc 应运而生 它主要是为对象分配内存和对不存活的对象进行回收 主要是堆得内存
    gc 是标准的 守护线程 
###2. 啥时候会进行垃圾收集
   1.当年轻代满了的时候会进行一次年轻代垃圾收集（也叫做 minor GC）。
    2.当老年代或永久代被填满了，会触发 major GC/full GC(只要年老代的连续空间大于新生代对象总大小
    或者历次晋升的平均大小就会进行major GC，否则将进行Full CG)
    3.当程序主动调用 System.gc() 的时候会通知进行gc 

###3.会对哪些对象进行收集？ 对象已死吗？
   首先要确定哪些对象是不需要的对象,会对这些对象进行标记,等待垃圾收集器收集.确认的方法有两个
   * 引用计数算法: 这个就是确定这个对象有没有被引用,如果被引用 就把这个数字加一,  但是解决不了循环引用的问题 即A->B,B->A
   * 可达性分析: 这个是从一系列 GC Roots(本地方法栈中，JNI引用的对象，方法区中的类静态属性引入的对象和常量引用对象都可以作为 GC Root。) 对象作为起点然后查找,查找一条引用链，被引用到的就算对象还活着 没有引用的 就标记
   
   首先判断哪些对象是没有被引用的会对其进行回收,也不是被引用了就不会被回收了 应用类型分为
   * 强引用: 当这个对象是通过 new 出来的时候 就是强引用 这个时候就算 内存不足 也不会回收这个对象 显示的设置为null 或者超出生命周期就会被回收
   * 软引用: 一般和 引用队列(ReferenceQueue) 配合使用 oom 之前会把软引用放进引用队列  内存不够时 会优先回收先放进队列的软引用
   * 弱引用:  每次垃圾回收 都会回收这个
   * 虚引用: 幽灵引用，不能用来取得一个对象的实例，唯一用途：当一个虚引用引用的对象被回收，系统会受到这个对象被回收了的通知。利用虚引用PhantomReference实现对象被回收时收到一个系统通知

###4.对象不可达的时候一定会死吗？
   确定一个对象真正的被回收要标记两次,第一次被标记之后会看对象有没有finalize()方法 如果重写了并且没有被执行过就会执行一次,如果在
   这个方法里面将对象引用了 那么就逃逸成功了.

###5.垃圾回收算法有哪些,各有什么优点和缺点？
   没有十全十美的垃圾回收算法 主要看要用在哪些地方.大体的垃圾回收算法分为
   * 标记-清除算法：看名字这个算法分为两个阶段 标记阶段和清除阶段 因为直接清除标记的 会导致产生大量的碎片(很多不连续的内存空间)
   * 复制算法: 为了不产生大量的碎片 将区域划分 将一个区域的存活的放到另一个区域然后清空这个区域 缺点是浪费一定的空间在复制的时候放存活的对象 基本上 eden 和service是这样划分出来的
   * 标记-整理算法: 这个相比较要浪费一定的内存来说 是将标记的移动到一段 缺点是效率不高 适合在老年代这样不频繁的区域
    
   ​年轻代适合 复制算法 young gc 把 eden 区的 可以用的对象 复制到service 区 然后 第二次young gc 将eden 新产生的和
   ​service 区 的复制到 to区    GC 后只有少量的对象存活
   ​老年代 适合 标记-整理算法 gc 不频繁 GC后对象存活率高
    
###6. 垃圾收集器有哪几种:
   收集器说到底就是对收集算法的一种实现,由于当代收集器都采用了分代算法 所以都是有年轻代和老年代的
   * Serial收集器: 在收集的时候必须要暂停其他进程 如果内存不是很大 那停顿的时间也就不长了
   * ParNew 收集器: 是对上面的多线程版本
   * Parallel Scavenge 收集器： 不懂
   * Serial Old收集器：Serial 的老年代版本 不懂改进了啥
   * CMS收集器: 使用标记-清除算法 注重服务相应 分为四个阶段
        * 初始标记: 这个就是最开始的标记 gc roots 能关联到的对象
        * 并发标记:  GC RootsTracing 关联到的对象
        * 最终标记: 修正在并发标记期间用户产生的变动
        * 并发清除: 清除
   * G1收集器: 基于标记-整理算法。将堆空间划分为大小相等的独立区域，每个区域有一个价值大小 维护一个列表 根据期望停顿时间优先回收最大价值的分区 
   和CMS 的区别都是分为四步 但是它维护一个列表 并且不和用户一起并发执行 最后一步是筛选回收

###Q: 为什么CMS收集器要用复制清除算法？
   首先CMS是和用户进程在一起执行的 垃圾回收途中会产生别的垃圾 如果这个时候用复制算法之类的就要暂停用户进程进行移动
   但是它是追求低延时的 所以他是以空间碎片换取低延迟
