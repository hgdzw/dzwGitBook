
#1. 什么是gc gc 有什么用
    套用一句话 围墙里的人想出去 围墙外的人想进来 java的内存管理机制就是一道围墙 程序员不需要知道内存中的事 不要直接和内存打交道
    gc 应运而生 它主要是为对象分配内存和 对不存活的对象进行回收
    gc 是标准的 守护线程 
#2. 啥时候会进行垃圾收集
    1.当年轻代满了的时候会进行一次年轻代垃圾收集（也叫做 minor GC）。
    2.当老年代或永久代被填满了，会触发 major GC/full GC(只要年老代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行major GC，否则将进行Full CG)
    3.当程序主动调用 System.gc() 的时候会进行gc 

##3. 垃圾收集器有哪几种:
​    分代收集器: 年轻代 老年代 永久代 每个代的空间是确定的
​    CMS收集器:
​    G1收集器: 1.8 之后用的  和上面几个的区别在于 别的都是 分代算法 的代空间是不固定的 是可变的

##4.垃圾收集算法:
​    判断是否可用算法(对象已死吗？):
​        可达性分析算法: 注明的 gc roots  本地方法栈中，JNI引用的对象，方法区中的类静态属性引入的对象和常量引用对象都可以作为 GC Root。
​        引用计数算法: 每有一个对象引用它 那他的计数器就加1 当计数器为0 时表示对象不再引用它
​    垃圾回收算法:
​        标记清除算法: 分为两个阶段  
​            ·标记阶段 标记需要回收的对象
​            ·清除阶段 标记完成后 统一回收
​        复制算法: 为了不产生 碎片 将内存分为两块 当一块用完 就将活着的对象 复制到另一块
​        标记-整理算法: 和标记清除算法类似 这个是将 标记的区域移动 不会产生内存碎片 适合老年代这样的gc  不频繁的区域
​        

### Q:年轻代和老年代 分辨适合什么样的垃圾回收算法
​    年轻代适合 复制算法 young gc 吧 eden 区的 可以用的对象 复制到service 区 然后 第二次young gc 将eden 新产生的和
​    service 区 的复制到 to区    GC 后只有少量的对象存活
​    老年代 适合 标记-整理算法 gc 不频繁 GC后对象存活率高

### Q:垃圾进行回收会对哪些进行回收？
​    首先判断哪些对象是没有被引用的会对其进行回收,也不是被引用了就不会被回收了 应用类型分为
​    强引用: 当这个对象是通过 new 出来的时候 就是强引用 这个时候就算 内存不足 也不会回收这个对象 显示的设置为null 或者超出生命周期就会被回收
​    软引用: 一般和 引用队列(ReferenceQueue) 配合使用 oom 之前会把软引用放进引用队列  内存不够时 会优先回收先放进队列的软引用
​    弱引用:  每次垃圾回收 都会回收这个
​    虚引用: 幽灵引用，不能用来取得一个对象的实例，唯一用途：当一个虚引用引用的对象被回收，系统会受到这个对象被回收了的通知。利用虚引用PhantomReference实现对象被回收时收到一个系统通知