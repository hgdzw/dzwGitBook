
java 对我们系统底层的IO进行了封装  我们不用关系底层是怎么操作io 的  只要做一个 API 调用师就行了  封装分为三个  BIO(同步阻塞io) NIO(同步非阻塞IO)  AIO(异步非阻塞)
同步和异步:
    同步: 指的是任务之间相互依赖 在A->B 模型中 b 必须等待 a执行完毕才可以执行 
    异步: 指的任务之间完全独立的 
阻塞和非阻塞(对于CPU来说的,java 指的就是线程):
    阻塞: 指的是cpu在这个时候不能处理别的请求 在这里阻塞了,就是线程在等待这个返回 不能做别的事
    非阻塞: 指的是 cpu 不用等待这个请求的返回 这个时候可以去做别的事情. 不用等待 这个返回了再回来处理 

BIO(同步阻塞io):
    这个时候 请求是一个请求一个socket 也就是一个线程 多个请求就 多开了几个线程 可以使用线程池来改善
NIO(同步非阻塞IO): 和传统io相比 他是非阻塞的 因为他有下面三个特征 所以和阻塞区分开
    缓冲区(buffer): 和传统io 将数据读取 然后写入 nio 是把数据读到或者写到这个缓冲区的 
    通道(Channel): 通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。
    选择器(Selecter): 一个线程管理多个 channel 是通过选择器来管理的 
    宗上所述  应该是:  一个线程 是通过选择器管理多个channel  和channel 是和buffer 链接的  所以这个时候一个线程可以同时处理多个请求 在请求进行io 等待的时候处理别的请求 
    netty 是对这上面的操作的封装 
AIO(异步非阻塞): 
    虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，
    接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    








